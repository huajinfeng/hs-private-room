# 20 类和对象

Python是一种面向对象的编程语言。在Python中，一切都是对象，都有其属性和方法。在程序中使用的数字、字符串、列表、字典、元组、集合等都是相应内置类的对象。我们创建类来创建对象。类就像一个对象构造器，或者说是创建对象的"蓝图"。我们实例化一个类来创建一个对象。类定义了对象的属性和行为，而对象则代表了类。
让我们检查一下Python中的一切是否都是类：

```py
C:\Users\Administrator> python
Python 3.11.9 (tags/v3.11.9:de54cf5, Apr  2 2024, 10:12:12) [MSC v.1938 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>> num = 10
>>> type(num)
<class 'int'>
>>> string = 'string'
>>> type(string)
<class 'str'>
>>> boolean = True
>>> type(boolean)
<class 'bool'>
>>> lst = []
>>> type(lst)
<class 'list'>
>>> tpl = ()
>>> type(tpl)
<class 'tuple'>
>>> set1 = set()
>>> type(set1)
<class 'set'>
>>> dct = {}
>>> type(dct)
<class 'dict'>
```

### 创建类
要创建一个类，我们需要关键字**class**，后跟类名和冒号。类名应该使用**驼峰命名法（CamelCase）**。
```sh
# 语法
class 类名:
  代码放在这里
```

**示例：**

```py
class Person:
  pass
print(Person)
```

```sh
<__main__.Person object at 0x10804e510>
```

### 创建对象
我们可以通过调用类来创建对象。
```py
p = Person()
print(p)
```

### 类构造函数

在上面的例子中，我们已经从Person类创建了一个对象。然而，没有构造函数的类在实际应用中并不真正有用。让我们使用构造函数使我们的类更有用。与Java或JavaScript中的构造函数一样，Python也有一个内置的**__init__**()构造函数。**__init__**构造函数有一个self参数，它是当前类实例的引用。
**示例：**
```py
class Person:
      def __init__ (self, name):
        # self允许将参数附加到类
          self.name = name

p = Person('hua')
print(p.name)
print(p)
```

```sh
# 输出
hua
<__main__.Person object at 0x2abf46907e80>
```
让我们向构造函数添加更多参数。
```py
class Person:
    def __init__(self, firstname, lastname, age, country, city):
        self.firstname = firstname
        self.lastname = lastname
        self.age = age
        self.country = country
        self.city = city
p = Person('hua', 'joffery', 13<<1, 'China', 'Suzhou')
print(p.firstname)
print(p.lastname)
print(p.age)
print(p.country)
print(p.city)
```

```sh
# 输出
hua
joffery
26
China
Suzhou
```

### 对象方法
对象可以有方法。方法是属于对象的函数。
**示例：**
```py
class Person:
      def __init__(self, firstname, lastname, age, country, city):
          self.firstname = firstname
          self.lastname = lastname
          self.age = age
          self.country = country
          self.city = city
      def person_info(self):
        return f'{self.firstname} {self.lastname}今年{self.age}岁。他住在{self.country}的{self.city}。'

p = Person('hua', 'joffery', 13<<1, 'China', 'Suzhou')
print(p.person_info())
```

```sh
# 输出
hua joffery今年26岁。他住在China的Suzhou。
```

### 对象默认方法
有时，你可能希望为对象方法提供默认值。如果我们为构造函数中的参数提供默认值，可以避免在不带参数调用或实例化类时出现错误。让我们看看这是什么样子：
**示例：**

```py
class Person:
      def __init__(self, firstname='hua', lastname='joffery', age=13<<1, country='China', city='Suzhou'):
          self.firstname = firstname
          self.lastname = lastname
          self.age = age
          self.country = country
          self.city = city

      def person_info(self):
        return f'{self.firstname} {self.lastname}今年{self.age}岁。他住在{self.country}的{self.city}。'

p1 = Person()
print(p1.person_info())
p2 = Person('wang', 'five', 30, 'China', 'Shanghai')
print(p2.person_info())
```

```sh
# 输出
hua joffery今年26岁。他住在China的Suzhou。
wang five今年30岁。他住在China的Shanghai。
```

### 修改类默认值的方法
在下面的例子中，person类的所有构造函数参数都有默认值。此外，我们还有一个skills参数，可以通过方法访问。让我们创建一个add_skill方法，向skills列表添加技能。

```py
class Person:
      def __init__(self, firstname='hua', lastname='joffery', age=13<<1, country='China', city='Suzhhou'):
          self.firstname = firstname
          self.lastname = lastname
          self.age = age
          self.country = country
          self.city = city
          self.skills = []

      def person_info(self):
        return f'{self.firstname} {self.lastname}今年{self.age}岁。他住在{self.country}的{self.city}。'
      def add_skill(self, skill):
          self.skills.append(skill)

p1 = Person()
print(p1.person_info())
p1.add_skill('HTML')
p1.add_skill('CSS')
p1.add_skill('JavaScript')
p2 = Person('wang', 'five', 30, 'China', 'Shanghai')
print(p2.person_info())
print(p1.skills)
print(p2.skills)
```

```sh
# 输出
hua joffery今年26岁。他住在China的Suzhhou。
wang five今年30岁。他住在China的Shanghai。
['HTML', 'CSS', 'JavaScript']
[]
```

### 继承

继承允许我们定义一个继承父类所有功能的类。它使代码可重用。

```py
# 语法
class 子类名(父类名):
    代码放在这里
```

让我们通过实际例子来看看继承的含义：

```py
class Student(Person):
    pass


s1 = Student('zhang', 'three', 30, 'China', 'Beijing')
s2 = Student('li', 'four', 28, 'China', 'Shenzheng')
print(s1.person_info())
s1.add_skill('JavaScript')
s1.add_skill('React')
s1.add_skill('Python')
print(s1.skills)
print(s2.person_info())
s2.add_skill('Organizing')
s2.add_skill('Marketing')
s2.add_skill('Digital Marketing')
print(s2.skills)
```

```sh
# 输出
zhang three今年30岁。他住在China的Beijing。
['JavaScript', 'React', 'Python']
li four今年28岁。他住在China的Shenzheng。
['Organizing', 'Marketing', 'Digital Marketing']
```

我们没有在Student类中调用任何方法，但我们能够访问来自Parent类的所有方法。Student类继承了Person类的__init__构造函数和person_info方法。如果我们想要向子类添加一个特定于子类的新方法，我们必须编写子类并在子类中创建新的方法。

```py
class Student(Person):
    def __init__ (self, firstname='hua', lastname='joffery',age=13<<1, country='China', city='Suzhou', gender='male'):
        self.gender = gender
        super().__init__(firstname, lastname,age, country, city)
    def person_info(self):
        gender = '他' if self.gender =='male' else '她'
        return f'{self.firstname} {self.lastname}今年{self.age}岁。{gender}住在{self.country}的{self.city}。'

s1 = Student('zhang', 'three', 30, 'China', 'Beijing','male')
s2 = Student('li', 'four', 28, 'China', 'Shenzheng','female')
print(s1.person_info())
s1.add_skill('JavaScript')
s1.add_skill('React')
s1.add_skill('Python')
print(s1.skills)
print(s2.person_info())
s2.add_skill('Organizing')
s2.add_skill('Marketing')
s2.add_skill('Digital Marketing')
print(s2.skills)
```

```sh
# 输出
zhang three今年30岁。他住在China的Beijing。
['JavaScript', 'React', 'Python']
li four今年28岁。她住在China的Shenzheng。
['Organizing', 'Marketing', 'Digital Marketing']
```

我们可以使用super()函数或父类名Person来自动继承父类的方法和属性。在上面的例子中，我们覆盖了父类方法。子类的person_info方法有不同的实现，即使方法名称与父类相同。

### 覆盖父类方法

如上所示，我们可以通过创建与父类方法名称相同的子类方法来覆盖父类方法。