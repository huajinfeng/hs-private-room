# 13 高阶函数
在 Python 中，可以对函数执行以下操作：
- 一个函数可以接收一个或多个函数作为参数
- 一个函数可以作为另一个函数的返回值
- 一个函数可以被修改
- 一个函数可以被赋值给变量

在本节中，我们将讨论：

1. 将函数作为参数传递
2. 将函数作为返回值返回
3. 使用 Python 闭包和装饰器

### 函数作为参数

```py
def sum_numbers(nums):  # 普通函数
    return sum(nums)    # 使用内置函数sum的函数

def higher_order_function(f, lst):  # 将函数作为参数
    summation = f(lst)
    return summation
result = higher_order_function(sum_numbers, [1, 2, 3, 4, 5])
print(result)       # 15
```

### 函数作为返回值

```py
def square(x):          # 求平方函数
    return x ** 2

def cube(x):            # 求立方函数
    return x ** 3

def absolute(x):        # 求绝对值函数
    if x >= 0:
        return x
    else:
        return -(x)

def higher_order_function(type): # 返回一个函数的高阶函数
    if type == 'square':
        return square
    elif type == 'cube':
        return cube
    elif type == 'absolute':
        return absolute

result = higher_order_function('square')
print(result(3))       # 9
result = higher_order_function('cube')
print(result(3))       # 27
result = higher_order_function('absolute')
print(result(-3))      # 3
```
从上述示例中可以看到，高阶函数根据传入的参数来返回不同的函数。

## Python 闭包
Python 允许嵌套函数访问外部封闭函数的作用域。 这称为闭包。 让我们看看闭包在 Python 中的工作原理。在 Python 中，闭包是通过在另一个封装函数内部嵌套函数，然后返回内部函数来创建的。请看下面的例子。

**示例：**

```py
def add_ten():
    ten = 10
    def add(num):
        return num + ten
    return add

closure_result = add_ten()
print(closure_result(5))  # 15
print(closure_result(10))  # 20
```
::: tip 代码执行流程：
1. 代码解析
```py
def add_ten():
    ten = 10             # 外部函数的局部变量
    def add(num):
        return num + ten # 内部函数引用了外部变量
    return add           # 返回内部函数对象本身
closure_result = add_ten()
print(closure_result(5))  # 输出 15
print(closure_result(10)) # 输出 20
```
### 执行步骤拆解
1. **调用 `add_ten()`**：
- 在函数内部定义了一个变量 `ten = 10`。
- 定义了一个内部函数 `add(num)`。
- **关键点**：它没有直接运行 `add`，而是把整个 `add` 函数作为“礼物”**返回**了出去。
2. **赋值给 `closure_result`**：
- 此时 `closure_result` 指向的就是内部的 `add` 函数。
- 即便 `add_ten()` 已经运行结束了，`ten = 10` 这个变量并没有被销毁，而是被 `add` 函数“打包”带走了。
3. **调用 `closure_result(5)`**：
- 实际上是在运行 `add(5)`，它计算 `5 + 10`（这个 10 就是当初打包带走的那个值），结果得到 **15**。
## 2. 闭包的三个必要条件
- **嵌套函数**：必须在一个函数内部定义另一个函数。
- **引用自由变量**：内部函数必须引用外部函数中的变量（非全局变量）。
- **返回内部函数**：外部函数必须将内部函数作为返回值。
## 3. 闭包的优势
| **特性**         | **描述**                                          |
| ---------------- | ------------------------------------------------- |
| **数据封装**     | 类似于类的私有属性，外界无法直接修改 `ten` 的值。 |
| **减少全局变量** | 避免了污染全局作用域，使代码更模块化。            |
| **状态保持**     | 能够跨调用保持函数的状态。                        |
## 4. 进阶对比：工厂模式
闭包允许我们根据参数生成特定的函数（即“函数工厂”）：
```py
def make_multiplier(n):
    def multiplier(x):
        return x * n
    return multiplier
double = make_multiplier(2) # 专门翻倍的函数
triple = make_multiplier(3) # 专门三倍的函数
print(double(5)) # 10
print(triple(5)) # 15
```
:::
## Python 装饰器
装饰器是一种设计模式，允许用户在不修改对象结构的情况下为其添加新功能。装饰器通常在你想要装饰的函数定义之前调用。
### 创建装饰器
要创建装饰器函数，我们需要一个带有内部包装器函数的外部函数。
**示例：**
```py
# 普通函数
def greeting():
    return 'Welcome to Python'
def uppercase_decorator(function):
    def wrapper():
        func = function()
        make_uppercase = func.upper() # upper()函数 将字符串转为大写
        return make_uppercase
    return wrapper
g = uppercase_decorator(greeting)
print(g())          # WELCOME TO PYTHON

# 使用装饰器实现上面的示例
'''这个装饰器函数是一个高阶函数，接收一个函数作为参数'''
def uppercase_decorator(function):
    def wrapper():
        func = function()
        make_uppercase = func.upper()
        return make_uppercase
    return wrapper
@uppercase_decorator #这一行是语法糖。它的效果等同于：greeting = uppercase_decorator(greeting)
def greeting():
    return 'Welcome to Python'
print(greeting())   # WELCOME TO PYTHON
```

### 将多个装饰器应用于单个函数
```py
'''这些装饰器函数是高阶函数，接收函数作为参数'''
# 第一个装饰器
def uppercase_decorator(function):
    def wrapper():
        func = function()
        make_uppercase = func.upper()
        return make_uppercase
    return wrapper
# 第二个装饰器
def split_string_decorator(function):
    def wrapper():
        func = function()
        splitted_string = func.split()
        return splitted_string
    return wrapper
@split_string_decorator
@uppercase_decorator     # 在此情况下，装饰器的顺序很重要 - .upper()函数不适用于列表
#实际的执行逻辑等同于greeting = split_string_decorator(uppercase_decorator(greeting))
def greeting():
    return 'Welcome to Python'
print(greeting())   # ['WELCOME', 'TO', 'PYTHON']
```

### 在装饰器函数中接受参数
大多数时候我们需要我们的函数接受参数，所以我们可能需要定义一个接受参数的装饰器。
```py
def decorator_with_parameters(function):
    def wrapper_accepting_parameters(para1, para2, para3):
        function(para1, para2, para3)
        print("I live in {}".format(para3))
    return wrapper_accepting_parameters
@decorator_with_parameters #decorator_with_parameters(print_full_name("Asabeneh", "Yetayeh",'Finland'))
def print_full_name(first_name, last_name, country):
    print("I am {} {}. I am learning python.".format(
        first_name, last_name))
print_full_name("hua", "joffery",'China')
```

## 内置高阶函数

在本部分中，我们将讨论一些内置的高阶函数，如*map()*, *filter*和*reduce*。
Lambda 函数可以作为参数传递，其最佳使用案例是在地图、过滤和减少等功能中。
### Python - Map 函数

map()函数是一个内置函数，接收一个函数和可迭代对象作为参数。
```py
    # 语法
    map(function, iterable)
```

**示例：1**

```py
numbers = [1, 2, 3, 4, 5] # 可迭代对象
def square(x):
    return x ** 2
numbers_squared = map(square, numbers)
print(list(numbers_squared))    # [1, 4, 9, 16, 25]
# 让我们应用lambda函数
numbers_squared = map(lambda x : x ** 2, numbers)
print(list(numbers_squared))    # [1, 4, 9, 16, 25]
```

**示例：2**

```py
numbers_str = ['1', '2', '3', '4', '5']  # 可迭代对象
numbers_int = map(int, numbers_str)
print(list(numbers_int))    # [1, 2, 3, 4, 5]
```

**示例：3**

```py
names = ['Zhang', 'Wang', 'Li', 'Zhao']  # 可迭代对象
def change_to_upper(name):
    return name.upper()
names_upper_cased = map(change_to_upper, names)
print(list(names_upper_cased)) 

# 让我们应用lambda函数
names_upper_cased = map(lambda name: name.upper(), names)
print(list(names_upper_cased))
```

map 函数实际上是迭代列表。例如，它将名称更改为大写并返回一个新列表。

### Python - Filter 函数
filter()函数调用指定函数，该函数对指定的可迭代对象（列表）中的每个项目返回布尔值。它过滤出满足过滤条件的项目。
```py
    # 语法
    filter(function, iterable)
```

**示例：1**

```py
# 让我们只过滤偶数
numbers = [1, 2, 3, 4, 5]  # 可迭代对象
def is_even(num):
    if num % 2 == 0:
        return True
    return False
even_numbers = filter(is_even, numbers)
print(list(even_numbers))
```
**示例：2**
```py
numbers = [1, 2, 3, 4, 5]  # 可迭代对象
def is_odd(num):
    if num % 2 != 0:
        return True
    return False
odd_numbers = filter(is_odd, numbers)
print(list(odd_numbers))       # [1, 3, 5]
```

```py
# 过滤长名称
names = ['Zhang', 'Wang', 'Li', 'Zhao']  # 可迭代对象
def is_name_long(name):
    if len(name) > 4:
        return True
    return False
long_names = filter(is_name_long, names)
print(list(long_names))
```

### Python - Reduce 函数
*reduce()*函数定义在 functools 模块中，我们需要从这个模块中导入它。像 map 和 filter 一样，它接收两个参数，一个函数和一个可迭代对象。然而，它不返回另一个可迭代对象，而是返回一个单一的值。
**示例：1**
```py
numbers_str = ['1', '2', '3', '4', '5']  # 可迭代对象
def add_two_nums(x, y):
    return int(x) + int(y)
total = reduce(add_two_nums, numbers_str)
print(total)    # 15
```
## 总结
### 1. 高阶函数的基础
- **作为参数**：可以将一个函数（如 `sum_numbers`）传递给另一个函数。
- **作为返回值**：一个函数可以根据条件动态地返回不同的函数对象（如 `square` 或 `cube`）。
闭包是指内部函数引用了外部嵌套函数中的变量，即使外部函数已经执行完毕，内部函数依然能“记住”并访问这些变量。

- **核心作用**：数据封装（类似私有变量）和保持函数状态。
- **示例**：`make_multiplier(n)` 可以根据参数生成“翻倍函数”或“三倍函数”。
### 3. 装饰器 (Decorators)
装饰器是闭包的一种高级应用，用于在不修改原函数代码的情况下，动态地为函数增加新功能。
- **语法糖**：使用 `@decorator_name` 符号简化调用。
- **常见用途**：日志记录、性能测试、权限校验、数据处理（如将输出转为大写）。
- **多层装饰**：可以同时给一个函数添加多个装饰器，执行顺序由内而外。
### 4. 内置高阶函数
文档列举了三个处理可迭代对象（如列表）的最常用工具：
| **函数**       | **作用**                                      | **结果**                 |
| -------------- | --------------------------------------------- | ------------------------ |
| **`map()`**    | 对序列中的每个元素应用同一个函数。            | 返回一个处理后的新序列。 |
| **`filter()`** | 根据函数返回的布尔值（True/False）筛选元素。  | 返回满足条件的子序列。   |
| **`reduce()`** | 对序列进行累积计算（需从 `functools` 导入）。 | 返回一个单一的数值。     |
